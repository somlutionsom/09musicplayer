'use client';

import { useEffect, useState, useCallback } from 'react';
import { useMusicPlayer } from "./hooks/useMusicPlayer";
import { useAuth } from "./hooks/useAuth";

export default function Home() {
  const [playerState, playerActions] = useMusicPlayer();
  const { user, signIn, signUp, signOut } = useAuth();
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [authMode, setAuthMode] = useState<'login' | 'signup'>('login');
  const [showYouTubeModal, setShowYouTubeModal] = useState(false);
  const [userSongs, setUserSongs] = useState<Array<{
    id: string;
    title: string;
    artist?: string;
    album?: string;
    duration_seconds?: number;
    source_type: string;
    file_url?: string;
    youtube_url?: string;
  }>>([]);
  const [showPlaylist, setShowPlaylist] = useState(false);
  // YouTube ÌîåÎ†àÏù¥Ïñ¥ ÌÉÄÏûÖ Ï†ïÏùò
  interface YouTubePlayer {
    getCurrentTime: () => number;
    getDuration: () => number;
    playVideo: () => void;
    pauseVideo: () => void;
    stopVideo: () => void;
    seekTo: (seconds: number, allowSeekAhead?: boolean) => void;
    destroy: () => void;
  }

  // YouTube API ÌÉÄÏûÖ Ï†ïÏùò
  interface YouTubeAPI {
    Player: new (elementId: string, config: unknown) => YouTubePlayer;
    PlayerState: {
      PLAYING: number;
      PAUSED: number;
      ENDED: number;
    };
  }

  const [youtubePlayer, setYoutubePlayer] = useState<YouTubePlayer | null>(null);
  const [isYouTubeAPIReady, setIsYouTubeAPIReady] = useState(false);
  const [albumCovers, setAlbumCovers] = useState<Record<string, string>>({});

  // YouTube ÎßÅÌÅ¨ Ï∂îÍ∞Ä Ìï∏Îì§Îü¨
  const handleYouTubeAdd = async (youtubeUrl: string, title: string, artist: string) => {
    console.log('üéµ YouTube ÏùåÏïÖ Ï∂îÍ∞Ä ÏãúÎèÑ:', { youtubeUrl, title, artist, userId: user?.id });
    
    if (!user) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
      return;
    }

    // ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï (30Ï¥à)
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('ÏöîÏ≤≠ ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.')), 30000);
    });

    try {
      const operationPromise = (async () => {
      const { supabase } = await import('./lib/supabase');
      console.log('üì° Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î°úÎìúÎê®');

      // Supabase Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
      console.log('üîó Supabase Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏãúÏûë...');
      const { data: connectionTest, error: connectionError } = await supabase
        .from('songs')
        .select('*')
        .limit(1);
      
      console.log('üîó Supabase Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Í≤∞Í≥º:', { connectionTest, connectionError });

      if (connectionError) {
        console.error('‚ùå Supabase Ïó∞Í≤∞ Ïã§Ìå®:', connectionError);
        alert('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + connectionError.message);
        return;
      }

      console.log('‚úÖ Supabase Ïó∞Í≤∞ ÏÑ±Í≥µ');

      // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê YouTube ÏùåÏïÖ Ï†ïÎ≥¥ Ï†ÄÏû•
      console.log('üíæ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• ÏãúÏûë...');
      const { data, error: dbError } = await supabase
        .from('songs')
        .insert({
          user_id: user.id,
          title: title || 'Unknown Title',
          artist: artist || 'Unknown Artist',
          source_type: 'youtube',
          youtube_url: youtubeUrl,
        })
        .select();

      console.log('üíæ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Í≤∞Í≥º:', { data, error: dbError });

      if (dbError) {
        console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Ïã§Ìå®:', dbError);
        alert('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Ïã§Ìå®: ' + dbError.message);
        return;
      }

        console.log('‚úÖ YouTube ÏùåÏïÖ Ï∂îÍ∞Ä ÏÑ±Í≥µ:', data);
        alert('YouTube ÏùåÏïÖÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§!');
        setShowYouTubeModal(false);
        // ÏùåÏïÖ Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
        if (user) {
          loadUserSongs();
        }
      })();

      // ÌÉÄÏûÑÏïÑÏõÉÍ≥º ÏûëÏóÖÏùÑ Í≤ΩÏüÅÏãúÌÇ¥
      await Promise.race([operationPromise, timeoutPromise]);
      
    } catch (error) {
      console.error('‚ùå YouTube Ï∂îÍ∞Ä Ï§ë Ïò§Î•ò:', error);
      alert('YouTube Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + (error as Error).message);
    }
  };

  // ÏÇ¨Ïö©Ïûê ÏùåÏïÖ Î™©Î°ù Î°úÎìú
  const loadUserSongs = useCallback(async () => {
    if (!user) {
      console.log('üë§ ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÌïòÏßÄ ÏïäÏùå');
      return;
    }

    console.log('üéµ ÏÇ¨Ïö©Ïûê ÏùåÏïÖ Î™©Î°ù Î°úÎìú ÏãúÏûë:', user.id);

    try {
      const { supabase } = await import('./lib/supabase');
      console.log('üì° Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î°úÎìúÎê® (ÏùåÏïÖ Î™©Î°ù)');
      
      const { data, error } = await supabase
        .from('songs')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      console.log('üìä ÏùåÏïÖ Î™©Î°ù Ï°∞Ìöå Í≤∞Í≥º:', { data, error });

      if (error) {
        console.error('‚ùå ÏùåÏïÖ Î™©Î°ù Î°úÎìú Ïã§Ìå®:', error);
        return;
      }

      console.log('‚úÖ ÏùåÏïÖ Î™©Î°ù Î°úÎìú ÏÑ±Í≥µ:', data?.length || 0, 'Í∞ú');
      setUserSongs(data || []);
      
      // Ïï®Î≤î Ïª§Î≤Ñ Î°úÎìú
      if (data && data.length > 0) {
        const covers: {[key: string]: string} = {};
        data.forEach(song => {
          if (song.album_cover) {
            covers[song.id] = song.album_cover;
          }
        });
        setAlbumCovers(covers);
        console.log('üñºÔ∏è Ïï®Î≤î Ïª§Î≤Ñ Î°úÎìúÎê®:', Object.keys(covers).length, 'Í∞ú');
      }
    } catch (error) {
      console.error('‚ùå ÏùåÏïÖ Î™©Î°ù Î°úÎìú Ï§ë Ïò§Î•ò:', error);
    }
  }, [user]);

  // ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏ Ïãú ÏùåÏïÖ Î™©Î°ù Î°úÎìú
  useEffect(() => {
    if (user) {
      loadUserSongs();
    } else {
      setUserSongs([]);
    }
  }, [user]);

  // YouTube API Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    // YouTube API Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú
    const script = document.createElement('script');
    script.src = 'https://www.youtube.com/iframe_api';
    script.onload = () => {
      // APIÍ∞Ä Î°úÎìúÎêòÎ©¥ onYouTubeIframeAPIReady Ìï®ÏàòÍ∞Ä Ìò∏Ï∂úÎê®
    };
    document.body.appendChild(script);

    // YouTube API Ï§ÄÎπÑ ÏΩúÎ∞± Ï†ÑÏó≠ Ìï®Ïàò ÏÑ§Ï†ï
    (window as unknown as { onYouTubeIframeAPIReady: () => void }).onYouTubeIframeAPIReady = () => {
      console.log('‚úÖ YouTube API Î°úÎìú ÏôÑÎ£å');
      setIsYouTubeAPIReady(true);
    };

    return () => {
      // ÌÅ¥Î¶∞ÏóÖ
      const existingScript = document.querySelector('script[src="https://www.youtube.com/iframe_api"]');
      if (existingScript) {
        existingScript.remove();
      }
    };
  }, []);

  // YouTube URLÏóêÏÑú ÎπÑÎîîÏò§ ID Ï∂îÏ∂ú
  const extractYouTubeVideoId = (url: string) => {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
  };

  // Ïï®Î≤î Ïª§Î≤Ñ ÏóÖÎ°úÎìú Ìï®Ïàò
  const handleAlbumCoverUpload = async () => {
    if (!playerState.currentTrack) {
      alert('Î®ºÏ†Ä Ïû¨ÏÉùÌï† Í≥°ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (!file) return;

      try {
        // Ïù¥ÎØ∏ÏßÄÎ•º Base64Î°ú Î≥ÄÌôò
        const reader = new FileReader();
        reader.onload = async (e) => {
          const base64Image = e.target?.result as string;
          
          if (user && playerState.currentTrack) {
            console.log('üñºÔ∏è Ïï®Î≤î Ïª§Î≤Ñ ÏóÖÎ°úÎìú Ï§ë:', playerState.currentTrack.title);
            
            // SupabaseÏóê Ïª§Î≤Ñ Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥ Ï†ÄÏû•
            const { supabase } = await import('./lib/supabase');
            const { error } = await supabase
              .from('songs')
              .update({ 
                album_cover: base64Image 
              })
              .eq('user_id', user.id)
              .eq('id', playerState.currentTrack.id);

            if (error) {
              console.error('‚ùå Ïª§Î≤Ñ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Ïã§Ìå®:', error);
              alert('Ïª§Î≤Ñ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
            } else {
              // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
              setAlbumCovers(prev => ({
                ...prev,
                [playerState.currentTrack!.id]: base64Image
              }));
              console.log('‚úÖ Ïï®Î≤î Ïª§Î≤Ñ Ï†ÄÏû•Îê®');
              alert('Ïï®Î≤î Ïª§Î≤ÑÍ∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!');
              // ÏÇ¨Ïö©Ïûê ÏùåÏïÖ Îã§Ïãú Î°úÎìú
              loadUserSongs();
            }
          } else {
            // Î°úÍ∑∏Ïù∏ÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Î°úÏª¨ÏóêÎßå Ï†ÄÏû•
            setAlbumCovers(prev => ({
              ...prev,
              [playerState.currentTrack!.id]: base64Image
            }));
            console.log('‚úÖ Ïï®Î≤î Ïª§Î≤Ñ Î°úÏª¨ Ï†ÄÏû•Îê®');
          }
        };
        
        reader.readAsDataURL(file);
      } catch (error) {
        console.error('‚ùå Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ïã§Ìå®:', error);
        alert('Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      }
    };
    
    input.click();
  };

  // ÌÖåÏä§Ìä∏Ïö© ÏÉòÌîå ÏùåÏïÖ Ï∂îÍ∞Ä Ìï®Ïàò
  const addSampleMusic = async () => {
    if (!user) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
      return;
    }

    const sampleTracks = [
      {
        title: "Sample Sound 1",
        artist: "Test Artist",
        album: "Demo Collection",
        source_type: "sample",
        file_url: "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+LyvmwhCjiN2e3QfS4GM3/J8duXQwsVYrjn7qxYFQlAmuH1umAhBzuN2O7KdSMJ",
        duration_seconds: 3
      },
      {
        title: "Sample Sound 2", 
        artist: "Demo Artist",
        album: "Test Album",
        source_type: "sample", 
        file_url: "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+LyvmwhCjiN2e3QfS4GM3/J8duXQwsVYrjn7qxYFQlAmuH1umAhBzuN2O7KdSMJ",
        duration_seconds: 3
      }
    ];

    try {
      const { supabase } = await import('./lib/supabase');
      
      for (const track of sampleTracks) {
        const { error } = await supabase
          .from('songs')
          .insert({
            user_id: user.id,
            ...track
          });

        if (error) {
          console.error('ÏÉòÌîå ÏùåÏïÖ Ï∂îÍ∞Ä Ïã§Ìå®:', error);
        }
      }

      alert('ÏÉòÌîå ÏùåÏïÖÏù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§!');
      loadUserSongs();
    } catch (error) {
      console.error('ÏÉòÌîå ÏùåÏïÖ Ï∂îÍ∞Ä Ï§ë Ïò§Î•ò:', error);
    }
  };

  // YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
  const createYouTubePlayer = useCallback((videoId: string) => {
    console.log('üé¨ YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ± ÏãúÎèÑ:', { videoId, isYouTubeAPIReady });
    
    if (!isYouTubeAPIReady) {
      console.error('‚ùå YouTube APIÍ∞Ä ÏïÑÏßÅ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§');
      alert('YouTube API Î°úÎî© Ï§ëÏûÖÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
      return null;
    }

    if (!videoId) {
      console.error('‚ùå Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎπÑÎîîÏò§ ID');
      return null;
    }

    try {
      // Í∏∞Ï°¥ ÌîåÎ†àÏù¥Ïñ¥ Ï†úÍ±∞
      if (youtubePlayer) {
        console.log('üóëÔ∏è Í∏∞Ï°¥ YouTube ÌîåÎ†àÏù¥Ïñ¥ Ï†úÍ±∞');
        youtubePlayer.destroy();
        setYoutubePlayer(null);
      }

      // ÌîåÎ†àÏù¥Ïñ¥ Ïª®ÌÖåÏù¥ÎÑà Ï§ÄÎπÑ
      let playerDiv = document.getElementById('youtube-player');
      if (playerDiv) {
        playerDiv.remove();
      }
      
      playerDiv = document.createElement('div');
      playerDiv.id = 'youtube-player';
      playerDiv.style.position = 'absolute';
      playerDiv.style.top = '-1000px';
      playerDiv.style.left = '-1000px';
      playerDiv.style.width = '1px';
      playerDiv.style.height = '1px';
      document.body.appendChild(playerDiv);

      const YT = (window as unknown as { YT: YouTubeAPI }).YT;
      console.log('üé• ÏÉà YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ± Ï§ë...', videoId);
      
      const player = new YT.Player('youtube-player', {
        height: '1',
        width: '1',
        videoId: videoId,
        playerVars: {
          'autoplay': 0,
          'controls': 0,
          'disablekb': 1,
          'fs': 0,
          'modestbranding': 1,
          'rel': 0,
          'iv_load_policy': 3,
          'cc_load_policy': 0,
          'start': 0,
          'end': 0
        },
        events: {
          'onReady': (event: { target: unknown }) => {
            console.log('‚úÖ YouTube ÌîåÎ†àÏù¥Ïñ¥ Ï§ÄÎπÑ ÏôÑÎ£å');
            // ÌîåÎ†àÏù¥Ïñ¥Î•º ÌõÖÏóêÎèÑ ÏÑ§Ï†ï
            playerActions.setYouTubePlayer(event.target as YouTubePlayer);
            
            // YouTube ÎπÑÎîîÏò§ Í∏∏Ïù¥ Í∞ÄÏ†∏Ïò§Í∏∞
            try {
              const player = event.target as YouTubePlayer;
              const duration = player.getDuration();
              if (duration && duration > 0) {
                if (playerState.currentTrack) {
                  playerActions.setCurrentTrack({
                    ...playerState.currentTrack,
                    duration: duration
                  });
                }
              }
            } catch (error) {
              console.error('YouTube Í∏∏Ïù¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
            }
          },
          'onStateChange': (event: { data: number }) => {
            console.log('üîÑ YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú Î≥ÄÍ≤Ω:', event.data);
            const YT = (window as unknown as { YT: YouTubeAPI }).YT;
            if (event.data === YT.PlayerState.PLAYING) {
              console.log('‚ñ∂Ô∏è YouTube Ïû¨ÏÉù ÏãúÏûëÎê®');
              playerActions.setPlaybackState('playing');
            } else if (event.data === YT.PlayerState.PAUSED) {
              console.log('‚è∏Ô∏è YouTube ÏùºÏãúÏ†ïÏßÄÎê®');
              playerActions.setPlaybackState('paused');
            } else if (event.data === YT.PlayerState.ENDED) {
              console.log('‚èπÔ∏è YouTube Ïû¨ÏÉù ÏôÑÎ£åÎê®');
              
              // Î∞òÎ≥µ Î™®ÎìúÍ∞Ä ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞ ÌòÑÏû¨ Í≥° Îã§Ïãú Ïû¨ÏÉù
              if (playerState.isRepeating) {
                console.log('üîÅ Î∞òÎ≥µ Î™®Îìú: YouTube ÌòÑÏû¨ Í≥° Îã§Ïãú Ïû¨ÏÉù');
                setTimeout(() => {
                  if (youtubePlayer) {
                    youtubePlayer.seekTo(0, true);
                    youtubePlayer.playVideo();
                  }
                }, 100);
                return;
              }
              
              // ÏûêÎèôÏúºÎ°ú Îã§Ïùå Í≥° Ïû¨ÏÉù
              if (playerState.playlist.length > 0) {
                const currentIndex = playerState.playlist.findIndex(track => track.id === playerState.currentTrack?.id);
                const nextIndex = (currentIndex + 1) % playerState.playlist.length;
                
                if (nextIndex !== currentIndex) { // ÎßàÏßÄÎßâ Í≥°Ïù¥ ÏïÑÎãàÎùºÎ©¥
                  console.log('üîÑ YouTube Ïû¨ÏÉù ÏôÑÎ£å ÌõÑ ÏûêÎèôÏúºÎ°ú Îã§Ïùå Í≥° Ïû¨ÏÉù');
                  playerActions.next();
                  // Îã§Ïùå Í≥°Ïù¥ ÏûêÎèôÏúºÎ°ú Ïû¨ÏÉùÎêòÎèÑÎ°ù ÏïΩÍ∞Ñ ÏßÄÏó∞ ÌõÑ Ïû¨ÏÉù
                  setTimeout(() => {
                    if (playerState.playbackState !== 'playing') {
                      playerActions.play();
                    }
                  }, 500);
                } else {
                  playerActions.setPlaybackState('stopped');
                }
              } else {
                playerActions.setPlaybackState('stopped');
              }
            }
          },
          'onError': (event: { data: number }) => {
            console.error('‚ùå YouTube ÌîåÎ†àÏù¥Ïñ¥ Ïò§Î•ò:', event.data);
            
            let errorMessage = 'YouTube ÎèôÏòÅÏÉÅÏùÑ Ïû¨ÏÉùÌï† Ïàò ÏóÜÏäµÎãàÎã§.\n\n';
            
            switch (event.data) {
              case 2:
                errorMessage += 'ÏûòÎ™ªÎêú ÎèôÏòÅÏÉÅ IDÏûÖÎãàÎã§.';
                break;
              case 5:
                errorMessage += 'HTML5 ÌîåÎ†àÏù¥Ïñ¥ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
                break;
              case 100:
                errorMessage += 'ÎèôÏòÅÏÉÅÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.\n(ÏÇ≠Ï†úÎêòÏóàÍ±∞ÎÇò ÎπÑÍ≥µÍ∞úÏùº Ïàò ÏûàÏäµÎãàÎã§)';
                break;
              case 101:
              case 150:
                errorMessage += 'Ïù¥ ÎèôÏòÅÏÉÅÏùÄ ÏûÑÎ≤†ÎìúÍ∞Ä ÌóàÏö©ÎêòÏßÄ ÏïäÏäµÎãàÎã§.\n(Ï†ÄÏûëÍ∂å Ï†úÌïú ÎòêÎäî ÏóÖÎ°úÎçî ÏÑ§Ï†ï)';
                break;
              default:
                errorMessage += `Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò (ÏΩîÎìú: ${event.data})`;
            }
            
            errorMessage += '\n\nÎã§Î•∏ YouTube ÎßÅÌÅ¨Î•º ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî.';
            
            alert(errorMessage);
            
            // Ïò§Î•ò Î∞úÏÉùÌïú ÎèôÏòÅÏÉÅÏùÑ ÌîåÎ†àÏù¥Î¶¨Ïä§Ìä∏ÏóêÏÑú ÌëúÏãú
            playerActions.setPlaybackState('stopped');
          }
        }
      });

      setYoutubePlayer(player);
      console.log('‚úÖ YouTube ÌîåÎ†àÏù¥Ïñ¥ Í∞ùÏ≤¥ ÏÉùÏÑ±Îê®');
      return player;
    } catch (error) {
      console.error('‚ùå YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ± Ïã§Ìå®:', error);
      alert('YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error);
      return null;
    }
  }, [isYouTubeAPIReady, youtubePlayer, playerActions, playerState.currentTrack]);

  // ÏùåÏïÖ ÏÑ†ÌÉù Ìï∏Îì§Îü¨
  const handleSongSelect = (song: {
    id: string;
    title: string;
    artist?: string;
    album?: string;
    duration_seconds?: number;
    source_type: string;
    file_url?: string;
    youtube_url?: string;
  }, index: number) => {
    let audioSrc = '';
    let isPlayable = false;
    let isYoutube = false;

    // Ïû¨ÏÉù Í∞ÄÎä•Ìïú ÏÜåÏä§ Í≤∞Ï†ï
    if (song.source_type === 'sample' && song.file_url) {
      audioSrc = song.file_url;
      isPlayable = true;
    } else if (song.source_type === 'upload' && song.file_url) {
      audioSrc = song.file_url;
      isPlayable = true;
    } else if (song.source_type === 'youtube' && song.youtube_url) {
      const videoId = extractYouTubeVideoId(song.youtube_url);
      console.log('üé¨ YouTube ÏùåÏïÖ ÏÑ†ÌÉù:', { title: song.title, videoId, youtube_url: song.youtube_url });
      
      if (!videoId) {
        alert(`ÏûòÎ™ªÎêú YouTube URLÏûÖÎãàÎã§: ${song.youtube_url}`);
        return;
      }
      
      if (!isYouTubeAPIReady) {
        alert('YouTube APIÍ∞Ä ÏïÑÏßÅ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      // YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
      const player = createYouTubePlayer(videoId);
      if (player) {
        isYoutube = true;
        isPlayable = true;
        audioSrc = song.youtube_url;
      } else {
        alert(`YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.`);
        return;
      }
    }

    const track = {
      id: song.id,
      title: song.title,
      artist: song.artist || 'Unknown Artist',
      album: song.album || 'Unknown Album',
      duration: song.duration_seconds || 180,
      src: audioSrc,
      isPlayable: isPlayable,
      isYoutube: isYoutube,
      youtubeId: isYoutube && song.youtube_url ? extractYouTubeVideoId(song.youtube_url) : null
    };

    // ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    playerActions.setCurrentTrack(track);
    playerActions.setCurrentTrackIndex(index);
    playerActions.setPlaylist(userSongs.map((s) => ({
      id: s.id,
      title: s.title,
      artist: s.artist || 'Unknown Artist',
      album: s.album || 'Unknown Album',
      duration: s.duration_seconds || 180,
      src: s.source_type === 'youtube' ? s.youtube_url : s.file_url,
      isPlayable: true,
      isYoutube: s.source_type === 'youtube',
      youtubeId: s.source_type === 'youtube' && s.youtube_url ? extractYouTubeVideoId(s.youtube_url) : null
    })));
    
    // ÏûêÎèô Ïû¨ÏÉùÌïòÏßÄ ÏïäÏùå - ÏÇ¨Ïö©ÏûêÍ∞Ä Ïû¨ÏÉù Î≤ÑÌäºÏùÑ Î™ÖÏãúÏ†ÅÏúºÎ°ú ÌÅ¥Î¶≠Ìï¥Ïïº Ìï®
    // (Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÏû¨ÏÉù Ï†ïÏ±Ö Ï§ÄÏàò)
    console.log('üéµ ÏùåÏïÖ ÏÑ†ÌÉùÎê®:', track.title, 'YouTube:', isYoutube, 'Playable:', isPlayable);
  };

  // ÌòÑÏû¨ Ìä∏Îûô Î≥ÄÍ≤Ω Ïãú YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
  useEffect(() => {
    if (playerState.currentTrack?.isYoutube && playerState.currentTrack?.youtubeId) {
      console.log('üéµ Ìä∏Îûô Î≥ÄÍ≤ΩÏúºÎ°ú YouTube ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏:', playerState.currentTrack.title);
      createYouTubePlayer(playerState.currentTrack.youtubeId);
    }
  }, [playerState.currentTrack?.id, playerState.currentTrack?.isYoutube, playerState.currentTrack?.youtubeId]);

  // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ ÏßÄÏõê
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      // ÏûÖÎ†• ÌïÑÎìúÏóêÏÑúÎäî Îã®Ï∂ïÌÇ§ ÎπÑÌôúÏÑ±Ìôî
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      switch (e.code) {
        case 'Space':
          e.preventDefault();
          if (playerState.playbackState === 'playing') {
            playerActions.pause();
          } else {
            playerActions.play();
          }
          break;
        case 'ArrowLeft':
          e.preventDefault();
          playerActions.previous();
          break;
        case 'ArrowRight':
          e.preventDefault();
          playerActions.next();
          break;
        case 'KeyS':
          e.preventDefault();
          playerActions.stop();
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [playerState.playbackState, playerActions]);

  return (
    <div className="min-h-screen bg-white flex items-center justify-center p-4">
      {/* Î©îÏù∏ ÏùåÏïÖ ÌîåÎ†àÏù¥Ïñ¥ ÏúàÎèÑÏö∞ */}
      <div 
        className="music-player-window"
        role="application"
        aria-label="Music Player 90s Interface"
      >
        {/* ÏúàÎèÑÏö∞ ÌÉÄÏù¥ÌãÄ Î∞î */}
        <div className="window-title-bar">
          <div className="window-title-text">som-player‚ô•</div>
          <div className="window-controls">
            <button className="window-control-btn minimize">_</button>
            <button className="window-control-btn maximize">‚ñ°</button>
            <button className="window-control-btn close">√ó</button>
          </div>
        </div>

        {/* Î©îÎâ¥ Î∞î */}
        <nav className="menu-bar" role="menubar" aria-label="Main menu">
          <button 
            className="menu-item" 
            role="menuitem" 
            tabIndex={0}
            onClick={() => setShowYouTubeModal(true)}
            style={{ cursor: 'pointer' }}
          >
            Music
          </button>
          <button 
            className="menu-item" 
            role="menuitem" 
            tabIndex={0}
            onClick={() => setShowPlaylist(!showPlaylist)}
            style={{ cursor: 'pointer' }}
          >
            Playlist
          </button>
          <button 
            className="menu-item" 
            role="menuitem" 
            tabIndex={0}
            onClick={() => user ? signOut() : setShowAuthModal(true)}
            style={{ cursor: 'pointer' }}
          >
            {user ? 'Log-out' : 'Log-in'}
          </button>
        </nav>

        {/* Ïï®Î≤î ÏïÑÌä∏ ÏÑπÏÖò */}
        <div className="album-art-section">
          <div 
            className="album-cover"
            role="img"
            aria-label={`Album art for ${playerState.currentTrack?.album || 'Unknown Album'}`}
            onClick={handleAlbumCoverUpload}
            style={{ 
              cursor: 'pointer',
              backgroundImage: playerState.currentTrack && albumCovers[playerState.currentTrack.id] 
                ? `url(${albumCovers[playerState.currentTrack.id]})` 
                : 'none',
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              backgroundRepeat: 'no-repeat'
            }}
            title="ÌÅ¥Î¶≠ÌïòÏó¨ Ïï®Î≤î Ïª§Î≤Ñ Î≥ÄÍ≤Ω"
          >
            {!(playerState.currentTrack && albumCovers[playerState.currentTrack.id]) && (
              <div className="album-placeholder">‚ô™</div>
            )}
          </div>
        </div>

        {/* Ìä∏Îûô Ï†ïÎ≥¥ Ìå®ÎÑê */}
        <div className="track-info-panel">
          <div className="track-title">
            {playerState.currentTrack?.title || 'No Track'}
            {playerState.playbackState === 'playing' && (
              <span className="playing-indicator" aria-label="Currently playing"></span>
            )}
          </div>
          <div className="artist-name">{playerState.currentTrack?.artist || 'No Artist'}</div>
        </div>

        {/* ÌîÑÎ°úÍ∑∏Î†àÏä§ ÏÑπÏÖò */}
        <div className="progress-section">
          <div className="time-display">
            <span className="current-time">{playerState.formattedCurrentTime}</span>
            <span className="total-time">{playerState.formattedDuration}</span>
          </div>
          <div className="progress-bar">
            <div 
              className="progress-track"
              onClick={(e) => {
                const rect = e.currentTarget.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const newTime = percent * playerState.duration;
                playerActions.seek(newTime);
              }}
              style={{ cursor: 'pointer' }}
              role="slider"
              aria-label="Progress bar"
              aria-valuemin={0}
              aria-valuemax={playerState.duration}
              aria-valuenow={playerState.currentTime}
              tabIndex={0}
              onKeyDown={(e) => {
                if (e.key === 'ArrowLeft') {
                  playerActions.seek(Math.max(0, playerState.currentTime - 10));
                } else if (e.key === 'ArrowRight') {
                  playerActions.seek(Math.min(playerState.duration, playerState.currentTime + 10));
                }
              }}
            >
              <div 
                className="progress-fill" 
                style={{ width: `${playerState.progress}%` }}
              ></div>
            </div>
          </div>
        </div>

        {/* Ïª®Ìä∏Î°§ Î≤ÑÌäºÎì§ */}
        <div className="control-buttons" role="group" aria-label="Playback controls">
          <button 
            className="control-btn"
            onClick={playerActions.previous}
            title="Previous Track"
          >
            ‚èÆ
          </button>
          <button 
            className="control-btn play-pause"
            onClick={() => {
              console.log('üéÆ Ïû¨ÏÉù Î≤ÑÌäº ÌÅ¥Î¶≠Îê®, ÌòÑÏû¨ ÏÉÅÌÉú:', playerState.playbackState);
              console.log('üéµ ÌòÑÏû¨ Ìä∏Îûô:', playerState.currentTrack?.title);
              if (playerState.playbackState === 'playing') {
                playerActions.pause();
              } else {
                playerActions.play();
              }
            }}
            title={playerState.playbackState === 'playing' ? 'Pause' : 'Play'}
          >
            {playerState.playbackState === 'playing' ? '‚è∏' : '‚ñ∂'}
          </button>
          <button 
            className="control-btn"
            onClick={playerActions.next}
            title="Next Track"
          >
            ‚è≠
          </button>
          <button 
            className={`control-btn repeat-btn ${playerState.isRepeating ? 'active' : ''}`}
            onClick={playerActions.toggleRepeat}
            title={playerState.isRepeating ? "Î∞òÎ≥µ Ìï¥Ï†ú" : "ÌïúÍ≥° Î∞òÎ≥µ"}
          >
            ‚ô•
          </button>
        </div>



        {/* ÌîåÎ†àÏù¥Î¶¨Ïä§Ìä∏ Ìå®ÎÑê */}
        {showPlaylist && user && (
          <div className="playlist-panel">
            <div className="playlist-header">
              <h4>MY PLAYLIST ‚ô°</h4>
            </div>
            <div className="playlist-content">
              {userSongs.length === 0 ? (
                <div className="empty-playlist">
                  <p>Ï∂îÍ∞ÄÎêú ÏùåÏïÖÏù¥ ÏóÜÏäµÎãàÎã§.</p>
                  <p>&quot;Music&quot; Î©îÎâ¥ÏóêÏÑú YouTube ÎßÅÌÅ¨Î•º Ï∂îÍ∞ÄÌï¥Î≥¥ÏÑ∏Ïöî!</p>
                </div>
              ) : (
                <div className="song-list">
                  {userSongs.map((song: { id: string; title: string; artist?: string; source_type: string }, index) => (
                    <div 
                      key={song.id} 
                      className={`song-item ${playerState.currentTrackIndex === index ? 'playing' : ''}`}
                      onClick={() => handleSongSelect(song, index)}
                    >
                      <div className="song-number">{index + 1}</div>
                      <div className="song-info">
                        <div className="song-title">{song.title}</div>
                        <div className="song-artist">{song.artist || 'Unknown Artist'}</div>
                      </div>
                      <div className="song-source">
                        {song.source_type === 'youtube' ? 'üíï' : 'üìÅ'}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}

      </div>

      {/* Ïù∏Ï¶ù Î™®Îã¨ */}
      {showAuthModal && (
        <AuthModal 
          mode={authMode}
          onClose={() => setShowAuthModal(false)}
          onModeChange={setAuthMode}
          onSignIn={signIn}
          onSignUp={signUp}
        />
      )}

              {/* YouTube Ï∂îÍ∞Ä Î™®Îã¨ */}
        {showYouTubeModal && (
          <YouTubeModal 
            onClose={() => setShowYouTubeModal(false)}
            onAddMusic={handleYouTubeAdd}
            onAddSample={addSampleMusic}
            user={user}
            extractYouTubeVideoId={extractYouTubeVideoId}
          />
        )}
    </div>
  );
}

// Ïù∏Ï¶ù Î™®Îã¨ Ïª¥Ìè¨ÎÑåÌä∏
function AuthModal({ 
  mode, 
  onClose, 
  onModeChange, 
  onSignIn, 
  onSignUp 
}: {
  mode: 'login' | 'signup';
  onClose: () => void;
  onModeChange: (mode: 'login' | 'signup') => void;
  onSignIn: (email: string, password: string) => Promise<{ data?: unknown; error?: { message: string } | null }>;
  onSignUp: (email: string, password: string) => Promise<{ data?: unknown; error?: { message: string } | null }>;
}) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const { error } = mode === 'login' 
        ? await onSignIn(email, password)
        : await onSignUp(email, password);

      if (error) {
        setError(error.message);
      } else {
        onClose();
      }
    } catch {
      setError('Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="auth-modal-overlay">
      <div className="auth-modal">
        <div className="auth-modal-header">
          <h3>{mode === 'login' ? 'Î°úÍ∑∏Ïù∏' : 'ÌöåÏõêÍ∞ÄÏûÖ'}</h3>
          <button onClick={onClose} className="close-btn">√ó</button>
        </div>
        
        <form onSubmit={handleSubmit} className="auth-form">
          
          <div className="form-group">
            <label>Ïù¥Î©îÏùº</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="your@email.com"
              required
            />
          </div>
          
          <div className="form-group">
            <label>ÎπÑÎ∞ÄÎ≤àÌò∏</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
              required
              minLength={6}
            />
          </div>
          
          {error && <div className="error-message">{error}</div>}
          
          <button type="submit" disabled={loading} className="submit-btn">
            {loading ? 'Ï≤òÎ¶¨Ï§ë...' : (mode === 'login' ? 'Î°úÍ∑∏Ïù∏' : 'ÌöåÏõêÍ∞ÄÏûÖ')}
          </button>
        </form>
        
        <div className="auth-switch">
          {mode === 'login' ? (
            <p>
              Í≥ÑÏ†ïÏù¥ ÏóÜÏúºÏã†Í∞ÄÏöî?{' '}
              <button onClick={() => onModeChange('signup')} className="link-btn">
                ÌöåÏõêÍ∞ÄÏûÖ
              </button>
            </p>
          ) : (
            <p>
              Ïù¥ÎØ∏ Í≥ÑÏ†ïÏù¥ ÏûàÏúºÏã†Í∞ÄÏöî?{' '}
              <button onClick={() => onModeChange('login')} className="link-btn">
                Î°úÍ∑∏Ïù∏
              </button>
            </p>
          )}
        </div>
      </div>
    </div>
  );
}

// YouTube Ï∂îÍ∞Ä Î™®Îã¨ Ïª¥Ìè¨ÎÑåÌä∏
function YouTubeModal({ 
  onClose, 
  onAddMusic, 
  onAddSample,
  user,
  extractYouTubeVideoId
}: {
  onClose: () => void;
  onAddMusic: (youtubeUrl: string, title: string, artist: string) => Promise<void>;
  onAddSample: () => Promise<void>;
  user: { id: string } | null;
  extractYouTubeVideoId: (url: string) => string | null;
}) {
  const [youtubeUrl, setYoutubeUrl] = useState('');
  const [title, setTitle] = useState('');
  const [artist, setArtist] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!user) {
      setError('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
      return;
    }

    if (!youtubeUrl.trim()) {
      setError('YouTube URLÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    // YouTube URL Í≤ÄÏ¶ù
          const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)[\w-]+(&[\w=&]*)?$/;
      if (!youtubeRegex.test(youtubeUrl)) {
        setError('Ïò¨Î∞îÎ•∏ YouTube URLÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.\nÏòà: https://www.youtube.com/watch?v=VIDEO_ID');
        return;
      }

      const videoId = extractYouTubeVideoId(youtubeUrl);
      if (!videoId || videoId.length !== 11) {
        setError('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ YouTube ÎèôÏòÅÏÉÅ IDÏûÖÎãàÎã§.');
        return;
      }

    setLoading(true);
    setError('');

    try {
      await onAddMusic(youtubeUrl, title, artist);
    } catch {
      setError('Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="auth-modal-overlay">
      <div className="auth-modal">
        <div className="auth-modal-header">
          <h3>YouTube ÏùåÏïÖ Ï∂îÍ∞Ä</h3>
          <button onClick={onClose} className="close-btn">√ó</button>
        </div>
        
        <form onSubmit={handleSubmit} className="auth-form">
          <div className="form-group">
            <label>YouTube URL *</label>
            <input
              type="url"
              value={youtubeUrl}
              onChange={(e) => setYoutubeUrl(e.target.value)}
              placeholder="https://www.youtube.com/watch?v=..."
              required
            />
          </div>
          
          <div className="form-group">
            <label>Ï†úÎ™© (ÏÑ†ÌÉùÏÇ¨Ìï≠)</label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="ÏùåÏïÖ Ï†úÎ™©"
            />
          </div>
          
          <div className="form-group">
            <label>ÏïÑÌã∞Ïä§Ìä∏ (ÏÑ†ÌÉùÏÇ¨Ìï≠)</label>
            <input
              type="text"
              value={artist}
              onChange={(e) => setArtist(e.target.value)}
              placeholder="ÏïÑÌã∞Ïä§Ìä∏ Ïù¥Î¶Ñ"
            />
          </div>
          
          {error && <div className="error-message">{error}</div>}
          
          <button type="submit" disabled={loading} className="submit-btn">
            {loading ? 'Ï∂îÍ∞Ä Ï§ë...' : 'ÏùåÏïÖ Ï∂îÍ∞Ä'}
          </button>
        </form>
        
        <div className="auth-switch">
          <p style={{ fontSize: '10px', color: 'var(--muted-foreground)', marginBottom: '12px' }}>
            YouTube ÎßÅÌÅ¨Î•º ÏûÖÎ†•ÌïòÎ©¥ ÌîåÎ†àÏù¥Î¶¨Ïä§Ìä∏Ïóê Ï∂îÍ∞ÄÎê©ÎãàÎã§.
          </p>
          <button 
            type="button"
            onClick={() => {
              onAddSample();
              onClose();
            }}
            className="link-btn"
            style={{ fontSize: '11px', textDecoration: 'none', background: 'var(--secondary)', padding: '6px 12px', borderRadius: '4px' }}
          >
            üéµ ÌÖåÏä§Ìä∏Ïö© ÏÉòÌîå ÏùåÏïÖ Ï∂îÍ∞Ä
          </button>
        </div>
      </div>
    </div>
  );
}
